import mu.KotlinLogging
import java.sql.*
import java.util.*
import java.util.concurrent.Executor

class AdoJdbcConnection(val configuration: AdoJdbcConfiguration) : Connection {
    val workItemsService = WorkItemService(configuration)
    private var isClosed = false
    private var properties: Properties = Properties()
    private val logger = KotlinLogging.logger {}

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        logger.trace { "unwrap $iface " }
        if (iface == null) {
            throw SQLException("Couldn't unwrap")
        }
        try {
            return iface.cast(this)
        } catch (cce: ClassCastException) {
            throw SQLException("Couldn't unwrap $iface")
        }
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        logger.trace { "isWrapperFor $iface " }
        return iface != null && iface.isInstance(this)
    }

    override fun close() {
        logger.trace { "close  " }
        this.isClosed = true
    }

    override fun createStatement(): Statement {
        logger.trace { "createStatement  " }
        return WiqlStatement(this)
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement {
        logger.trace { "createStatement $resultSetType $resultSetConcurrency " }
        return WiqlStatement(this)
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement {
        logger.trace { "createStatement $resultSetType $resultSetConcurrency $resultSetHoldability " }
        return WiqlStatement(this)
    }

    override fun prepareStatement(sql: String?): PreparedStatement {
        logger.trace { "prepareStatement $sql " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        logger.trace { "prepareStatement $sql $resultSetType $resultSetConcurrency " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun prepareStatement(
        sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int
    ): PreparedStatement {
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun prepareStatement(sql: String?, autoGeneratedKeys: Int): PreparedStatement {
        logger.trace { "prepareStatement $sql $autoGeneratedKeys " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun prepareStatement(sql: String?, columnIndexes: IntArray?): PreparedStatement {
        logger.trace { "prepareStatement $sql $columnIndexes " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun prepareStatement(sql: String?, columnNames: Array<out String>?): PreparedStatement {
        logger.trace { "prepareStatement $sql $columnNames " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun prepareCall(sql: String?): CallableStatement {
        logger.trace { "prepareCall $sql " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int): CallableStatement {
        logger.trace { "prepareCall $sql $resultSetType $resultSetConcurrency " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun prepareCall(
        sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int
    ): CallableStatement {
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun nativeSQL(sql: String?): String {
        logger.trace { "nativeSQL $sql " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun setAutoCommit(autoCommit: Boolean) {
        logger.trace { "setAutoCommit $autoCommit " }
    }

    override fun getAutoCommit(): Boolean {
        logger.trace { "getAutoCommit  " }
        return true
    }

    override fun commit() {
        logger.trace { "commit  " }
    }

    override fun rollback() {
        logger.trace { "rollback  " }
    }

    override fun rollback(savepoint: Savepoint?) {
        logger.trace { "rollback $savepoint " }
    }

    override fun isClosed(): Boolean {
        logger.trace { "isClosed  " }
        return this.isClosed
    }

    override fun getMetaData(): AdoJdbcDatabaseMetaData {
        logger.trace { "getMetaData  " }
        return AdoJdbcDatabaseMetaData(this)
    }

    override fun setReadOnly(readOnly: Boolean) {
        logger.trace { "setReadOnly $readOnly " }
    }

    override fun isReadOnly(): Boolean {
        logger.trace { "isReadOnly  " }
        return true
    }

    override fun setCatalog(catalog: String?) {
        logger.trace { "setCatalog $catalog " }
    }

    override fun getCatalog(): String? {
        logger.trace { "getCatalog  " }
        return null
    }

    override fun setTransactionIsolation(level: Int) {
        logger.trace { "setTransactionIsolation $level " }

    }

    override fun getTransactionIsolation(): Int {
        logger.trace { "getTransactionIsolation  " }
        return Connection.TRANSACTION_NONE
    }

    override fun getWarnings(): SQLWarning? {
        logger.trace { "getWarnings  " }
        return null
    }

    override fun clearWarnings() {
        logger.trace { "clearWarnings  " }
    }

    override fun getTypeMap(): MutableMap<String, Class<*>> {
        logger.trace { "getTypeMap  " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun setTypeMap(map: MutableMap<String, Class<*>>?) {
        logger.trace { "setTypeMap $map" }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun setHoldability(holdability: Int) {
        logger.trace { "setHoldability $holdability " }
    }

    override fun getHoldability(): Int {
        logger.trace { "getHoldability  " }
        return ResultSet.HOLD_CURSORS_OVER_COMMIT
    }

    override fun setSavepoint(): Savepoint {
        logger.trace { "setSavepoint  " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun setSavepoint(name: String?): Savepoint {
        logger.trace { "setSavepoint $name " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun releaseSavepoint(savepoint: Savepoint?) {
        logger.trace { "releaseSavepoint $savepoint " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun createClob(): Clob {
        logger.trace { "createClob  " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun createBlob(): Blob {
        logger.trace { "createBlob  " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun createNClob(): NClob {
        logger.trace { "createNClob  " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun createSQLXML(): SQLXML {
        logger.trace { "createSQLXML  " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun isValid(timeout: Int): Boolean {
        logger.trace { "isValid $timeout " }
        return !this.isClosed
    }

    override fun setClientInfo(name: String?, value: String?) {
        logger.trace { "setClientInfo $name $value " }
        this.properties.put(name, value)
    }

    override fun setClientInfo(properties: Properties?) {
        logger.trace { "setClientInfo $properties " }
        if (properties != null) {
            this.properties.putAll(properties)
        }
    }

    override fun getClientInfo(name: String?): String {
        logger.trace { "getClientInfo $name " }
        val property = this.properties.getProperty(name) ?: ""
        return property
    }

    override fun getClientInfo(): Properties {
        logger.trace { "getClientInfo  " }
        return this.properties
    }

    override fun createArrayOf(typeName: String?, elements: Array<out Any>?): java.sql.Array {
        logger.trace { "createArrayOf $typeName $elements " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun createStruct(typeName: String?, attributes: Array<out Any>?): Struct {
        logger.trace { "createStruct $typeName $attributes " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun setSchema(schema: String?) {
        logger.trace { "setSchema $schema " }
    }

    override fun getSchema(): String? {
        logger.trace { "getSchema  " }
        return null
    }

    override fun abort(executor: Executor?) {
        logger.trace { "abort $executor " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        logger.trace { "setNetworkTimeout $executor $milliseconds " }
        throw SQLFeatureNotSupportedException("not implemented")
    }

    override fun getNetworkTimeout(): Int {
        logger.trace { "getNetworkTimeout  " }
        throw SQLFeatureNotSupportedException("not implemented")
    }
}
